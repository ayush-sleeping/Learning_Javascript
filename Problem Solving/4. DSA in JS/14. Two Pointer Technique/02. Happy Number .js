// Happy Number
/*
Write an algorithm to determine if a number n is happy.
A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.


Example 1:
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1


Example 2:
Input: n = 2
Output: false


Topics : Hash Table, Math, Two Pointers
*/

// Converts the number to a string to easily access each digit.
// Using a for loop to square and sum each digit.
// Using a count variable to avoid infinite loops (instead of a hash table or two pointers).
// If the process reaches 1 within 100 steps, it returns true; otherwise, it returns false.

function isHappy(n) {
    // helper to get sum of squares of digits
    function sumOfSquares(num) {
        let str = "" + num;   // convert number to string
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            let digit = str[i] * 1;  // convert char to number
            sum += digit * digit;
        }
        return sum;
    }

    let count = 0; // avoid infinite loop
    while (n !== 1 && count < 100) {
        n = sumOfSquares(n);
        count++;
    }

    return n === 1;
}
console.log(isHappy(19)); // true
console.log(isHappy(2));  // false



/**
APPROACH:
- I need to check if a number is a "happy number".
- A happy number is a number that, when I keep replacing it with the sum of the squares of its digits, eventually becomes 1.
- If I see the same number again (cycle), then it's not a happy number.

How I will solve it:
I'll use a plain JS object to keep track of numbers I've already seen (to detect cycles).
I'll use a loop:
   - If n becomes 1, I'll return true (it's happy).
   - If n is already in my object, I'll return false (cycle found).
   - Otherwise, I'll mark n as seen.
   - Then, I'll calculate the sum of the squares of its digits:
     - I'll use a while loop: get each digit with n % 10, square it, add to sum, then remove the digit with n = Math.floor(n / 10).
   - I'll set n to this sum and repeat.
*/


/**
 * @param {number} n
 * @return {boolean}
*/
var isHappy = function (n) {
    let seen = {};
    while (true) {
        if (n === 1) {
            return true;
        }
        if (seen[n]) {
            return false;
        }
        seen[n] = true;

        let sum = 0;
        let temp = n;
        while (temp > 0) {
            let digit = temp % 10;
            sum = sum + (digit * digit);
            temp = (temp - (temp % 10)) / 10;
        }
        n = sum;
    }
};




// lets understand this code more using comments :
var isHappy = function (n) {
    let seen = {}; // Hash Table: to keep track of numbers we've already seen

    while (true) {
        if (n === 1) {
            return true; // If n becomes 1, it's a happy number
        }
        if (seen[n]) {
            return false; // If n is already seen, cycle detected (not happy)
        }
        seen[n] = true; // Mark n as seen

        let sum = 0;
        let temp = n;
        while (temp > 0) {
            let digit = temp % 10;           // Get last digit
            sum = sum + (digit * digit);     // Add square of digit to sum

            // Remove last digit without Math.floor:
            // Subtract remainder, then divide by 10 (integer division)
            temp = (temp - (temp % 10)) / 10;
        }
        n = sum; // Set n to the sum and repeat
    }
};


// Two pointer way :
// Two Pointer (Floyd's Cycle Detection) approach,
var isHappy = function (n) {
    // Helper function to get sum of squares of digits
    function getNext(num) {
        let sum = 0;
        let temp = num;
        while (temp > 0) {
            let digit = temp % 10;                  // Get last digit
            sum = sum + (digit * digit);            // Add square of digit to sum
            temp = (temp - (temp % 10)) / 10;       // Remove last digit (integer division)
        }
        return sum;
    }

    let slow = n;           // Slow pointer
    let fast = n;           // Fast pointer

    // The while loop keeps moving both pointers through the sequence of numbers generated by the sum of squares process.
    // If either pointer reaches 1, the number is happy and we return true.
    // If the pointers meet at a value other than 1, it means we've entered a cycle (not happy), so we return false.
    // This loop continues until one of those two conditions is met.
    while (true) {
        slow = getNext(slow);           // Move slow pointer by 1 step
        fast = getNext(getNext(fast));  // Move fast pointer by 2 steps

        if (slow === 1 || fast === 1) {
            return true;                // If either pointer reaches 1, it's a happy number
        }
        if (slow === fast) {
            return false;               // Cycle detected (not happy)
        }
    }
};
console.log(isHappy(19)); // true
console.log(isHappy(2));  // false
